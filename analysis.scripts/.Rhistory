lines(density(pop2))
obs.stat <- mean(pop1) - mean(pop2)
obs.stat <- round(mean(pop1) - mean(pop2), digits=4)
c(pop1, pop2)
new.dat <- sample(c(pop1, pop2))
mean(new.dat[1:110) - mean(new.dat[111:220])
sim.stat <- mean(new.dat[1:110]) - mean(new.dat[111:220])
sim.stat <- c()
for(i in 1:1000){
new.dat <- sample(c(pop1, pop2))
sim.stat[i] <- mean(new.dat[1:110]) - mean(new.dat[111:220])
}
plot(density(sim.stat))
abline(v=obs.stat, col="red")
obs.stat<sim.stat
obs.stat>sim.stat
sim.stat<obs.stat
sum(sim.stat<obs.stat)
sum(sim.stat<obs.stat)/length(sim.stat)
for(i in 1:10000){
new.dat <- sample(c(pop1, pop2))
sim.stat[i] <- mean(new.dat[1:110]) - mean(new.dat[111:220])
}
plot(density(sim.stat))
abline(v=obs.stat, col="red") #this shows that the observed data is very different than the expected (simulated data)
sum(sim.stat<obs.stat)/length(sim.stat)
sum(sim.stat<obs.stat)
install.packages("car")
#t.test
data("iris")
#permutations
view(iris)
#permutations
View(iris)
hist(iris$Sepal.Width)
boxplot(iris$Sepal.Width~iris$Species)
help("t.test")
iris$Species == "versicolor"
t.test(x=iris$Sepal.Width[iris$Species == "versicolor"],
y=iris$Sepal.Width[iris$Species == "virginica"])
#paired t.test
init.bp <- sample(rnorm(n=100, mean=180, sd=10))
hist(init.bp)
help(rnorm)
#now we are treating these patients with bp meds
post.bp <- sample(rnorm(n=100, mean=(init.bp-20) ,
sd=10))
plot(post.bp~init.bp)
t.test(x=init.bp, y=post.bp, paired=T, alternative="l")
t.test(y=init.bp, x=post.bp, paired=T, alternative="l")
hist(init.bp-post.bp)
#one sample t.test
#difference between what we expect and what we observe. Is there a change? Yes or not
spawners <- rpois(10, 450)
t.test(spawners, mu=450)
samp1 <- rexp(n=500, rate=1)
samp2 <- rexp(500, rate=1.5)
print(i)
for(i in 1:1000)
print(i)
samp1 <- rexp(n=500, rate=1)
samp2 <- rexp(500, rate=1.5)
for(i in 1:1000)
print(i)
for(i in 1:1000){
print(i)
}
s1 <- rexp(n=350, rate=1)
s2 <- rexp(350, rate=1.5)
for(i in 1:1000){
new.pop<- sample(c(s1, s2))
}
rm(samp1)
rm(samp2)
s1 <- rexp(n=350, rate=1)
s2 <- rexp(350, rate=1.5)
diff <- c()
#repeat this 1000 times
for(i in 1:1000){ #next line is making a new population
new.pop<- sample(c(s1, s2))
diff <- mean(new.pop[1:350]) -
mean(new.pop[351:700]) #this is when you add line 43 as diff as an empty vector
}
s1 <- rexp(n=350, rate=1)
s2 <- rexp(350, rate=1.5)
diff <- c()
#repeat this 1000 times
for(i in 1:1000){ #next line is making a new population
new.pop<- sample(c(s1, s2))
diff[i]<- mean(new.pop[1:350]) -
mean(new.pop[351:700]) #this is when you add line 43 as diff as an empty vector
}
plot(density(diff))
plot(density(diff))
obs.stat <- mean(s1)-mean(s2)
abline(v=obs.stat)
emp.pval <- sum(diff > obs.stat)/length(diff)
plot(density(diff))
s1 <- rexp(n=350, rate=1)
s2 <- rexp(350, rate=1.1)
diff <- c()
#repeat this 1000 times
for(i in 1:1000){ #next line is making a new population
new.pop<- sample(c(s1, s2))
diff[i]<- mean(new.pop[1:350]) -
mean(new.pop[351:700]) #this is when you add line 43 as diff as an empty vector
}
plot(density(diff))
obs.stat <- mean(s1)-mean(s2)
abline(v=obs.stat)
emp.pval <- sum(diff > obs.stat)/length(diff)
power.t.test(, delta=25, sd=50, sig.level = .01, power=.8)
install.packages("ggplot2")
install.packages("ggraptR")
install.packages("viridis")
load("results.young.RData")
setwd("~/Downloads")
load("results.young.RData")
names(all.results.young)
fixX <- fixY <- fixA <- c()
for (i in 1:500){
fixX[i] <- sum(all.results.young$X$`1.45e-12`[,i]==1)/500
fixY[i] <- sum(all.results.young$Y$`1.45e-12`[,i]==1)/500
fixA[i] <- sum(all.results.young$A$`1.45e-12`[,i]==1)/500
}
plot(fixX, type="l", ylim=c(0,1))
lines(fixA, col="red")
lines(fixY, col="blue")
load("results.old.RData")
names(all.results.old)
fixX <- fixY <- fixA <- c()
for (i in 1:500){
fixX[i] <- sum(all.results.old$X$`1.45e-12`[,i]==1)/500
fixY[i] <- sum(all.results.old$Y$`1.45e-12`[,i]==1)/500
fixA[i] <- sum(all.results.old$A$`1.45e-12`[,i]==1)/500
}
plot(fixX, type="l", ylim=c(0,1))
lines(fixA, col="red")
lines(fixY, col="blue")
setwd("~/Desktop/Repositories/plantmorph")
library(SAGA2)
library(viridis)
# leaf area excluding F1
dat <- read.csv("area.csv")
setwd("~/Desktop/Repositories/plantmorph/analysis.scripts")
# leaf area excluding F1
dat <- read.csv("area.csv")
library(SAGA2)
library(viridis)
# leaf area excluding F1
dat <- read.csv("../data/area.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Area")
res$estimates
res$varimp
library(SAGA2)
library(viridis)
# leaf perimeter excluding F1
dat <- read.csv("../data/perimeter.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Perimeter")
res$estimates
res$varimp
# RPA excluding F1
dat <- read.csv("../data/RPA.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Ratio of Perimeter to Area")
res$estimates
res$varimp
# length excluding F1
dat <- read.csv("../data/length.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Length")
res$estimates
res$varimp
# width excluding F1
dat <- read.csv("../data/width.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Width")
res$estimates
res$varimp
# roundness excluding F1
dat <- read.csv("../data/RWL.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Ratio of Width to Length")
res$estimates
res$varimp
# symmetry excluding F1
dat <- read.csv("../data/AR.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), min.vi = 0.25, main = "Areal Ratio")
res$estimates
res$varimp
# seed weight excluding F1
dat <- read.csv("../data/seed mass.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Seed Mass")
res$estimates
res$varimp
setwd("~/Desktop/Repositories/plantmorph/analysis.scripts")
# read in results file
dat <- read.csv("../results/resultsNOF1.csv")
# function that takes in raw LCA results and returns the proportion of additive,
# dominance, and epistatic genetic effects for each dataset
procLCA <- function(x){
mcomp <- rep(0, 3)
est <- x[1, 3:12] #beta coefficients
# following two lines are checking if the se overlaps zero and if the variable importance
# is greater than or equal to 0.5 for each cge. only keeping cges that meet those criteria
est[1, ] <- abs(est[1,]) #taking the absolute value of beta coefficients - keep the abs for later
magcheck <- est[1, ] > x[2, 3:12] #is the beta coeff larger than the se? if so, keep that cge
vicheck <- x[3,3:12] >= .5 #is the variable importance above 0.5? if so, keep that cge
cge <- colnames(est)[magcheck & vicheck]
cge.est <- est[1, ][magcheck & vicheck]
# identifying possible cges for each type of genetic effects
additive <- c("Aa", "Ca", "Mea", "Xa", "Ya","Ma")
dominance <- c("Ad", "Med", "Xd", "Md")
epistatic <- c("AaXa", "AaXd", "AdXd", "XaXd", "XdXd", "XdCa", "AaYa",
"AaAa", "AaAd", "AaCa", "AdAd", "AdXa", "AdYa", "XaYa",
"YaCa", "XaXa", "XaCa", "AdCa", "XaAa", "XaAd", "CaXa",
"CaYa", "CaXd", "AaWa")
#taking the sum of the cges that go into each category (add, dom, epi)
mcomp[1] <- sum(cge.est[cge %in% additive])
mcomp[2] <- sum(cge.est[cge %in% dominance])
mcomp[3] <- sum(cge.est[cge %in% epistatic])
#scale and sum the components to one
names(mcomp) <- c("add","dom", "epi")
mcomp <- mcomp/sum(mcomp)
return(mcomp)
}
# loop that completes procLCA function on result file
final.results <- as.data.frame(matrix(NA, 1,4))
colnames(final.results) <- c("add","dom","epi","file")
# add counter for which row to put results in
counter<-1
for(i in seq(from=1, by=3, length.out=(nrow(dat)/3))){
curdat <- dat[i:(i+2),]
final.results[counter, 1:3] <- procLCA(curdat) #add, dom, epi component for each dataset
final.results[counter, 4] <- dat$file[i] #file name
counter <- counter + 1
}
# saving final.results as a csv to desktop
directory <-getwd()
directory
View(final.results)
# read in results file
dat <- read.csv("../results/resultsNOF1.csv")
# function that takes in raw LCA results and returns the proportion of additive,
# dominance, and epistatic genetic effects for each dataset
procLCA <- function(x){
mcomp <- rep(0, 3)
est <- x[1, 3:12] #beta coefficients
# following two lines are checking if the se overlaps zero and if the variable importance
# is greater than or equal to 0.5 for each cge. only keeping cges that meet those criteria
est[1, ] <- abs(est[1,]) #taking the absolute value of beta coefficients - keep the abs for later
magcheck <- est[1, ] > x[2, 3:12] #is the beta coeff larger than the se? if so, keep that cge
vicheck <- x[3,3:12] >= .5 #is the variable importance above 0.5? if so, keep that cge
cge <- colnames(est)[magcheck & vicheck]
cge.est <- est[1, ][magcheck & vicheck]
# identifying possible cges for each type of genetic effects
additive <- c("Aa", "Ca", "Mea", "Xa", "Ya","Ma")
dominance <- c("Ad", "Med", "Xd", "Md")
epistatic <- c("AaXa", "AaXd", "AdXd", "XaXd", "XdXd", "XdCa", "AaYa",
"AaAa", "AaAd", "AaCa", "AdAd", "AdXa", "AdYa", "XaYa",
"YaCa", "XaXa", "XaCa", "AdCa", "XaAa", "XaAd", "CaXa",
"CaYa", "CaXd", "AaWa")
#taking the sum of the cges that go into each category (add, dom, epi)
mcomp[1] <- sum(cge.est[cge %in% additive])
mcomp[2] <- sum(cge.est[cge %in% dominance])
mcomp[3] <- sum(cge.est[cge %in% epistatic])
#scale and sum the components to one
names(mcomp) <- c("add","dom", "epi")
mcomp <- mcomp/sum(mcomp)
return(mcomp)
}
# loop that completes procLCA function on result file
final.results <- as.data.frame(matrix(NA, 1,4))
View(final.results)
colnames(final.results) <- c("add","dom","epi","file")
View(final.results)
for(i in seq(from=1, by=3, length.out=(nrow(dat)/3))){
curdat <- dat[i:(i+2),]
final.results[counter, 1:3] <- procLCA(curdat) #add, dom, epi component for each dataset
final.results[counter, 4] <- dat$file[i] #file name
counter <- counter + 1
}
# add counter for which row to put results in
counter<-1
for(i in seq(from=1, by=3, length.out=(nrow(dat)/3))){
curdat <- dat[i:(i+2),]
final.results[counter, 1:3] <- procLCA(curdat) #add, dom, epi component for each dataset
final.results[counter, 4] <- dat$file[i] #file name
counter <- counter + 1
}
View(final.results)
View(final.results)
# read in results file
dat <- read.csv("../results/resultsNOF1.csv")
# function that takes in raw LCA results and returns the proportion of additive,
# dominance, and epistatic genetic effects for each dataset
procLCA <- function(x){
mcomp <- rep(0, 3)
est <- x[1, 3:12] #beta coefficients
# following two lines are checking if the se overlaps zero and if the variable importance
# is greater than or equal to 0.5 for each cge. only keeping cges that meet those criteria
est[1, ] <- abs(est[1,]) #taking the absolute value of beta coefficients - keep the abs for later
magcheck <- est[1, ] > x[2, 3:12] #is the beta coeff larger than the se? if so, keep that cge
vicheck <- x[3,3:12] >= .5 #is the variable importance above 0.5? if so, keep that cge
cge <- colnames(est)[magcheck & vicheck]
cge.est <- est[1, ][magcheck & vicheck]
# identifying possible cges for each type of genetic effects
additive <- c("Aa", "Ca", "Mea", "Xa", "Ya","Ma")
dominance <- c("Ad", "Med", "Xd", "Md")
epistatic <- c("AaXa", "AaXd", "AdXd", "XaXd", "XdXd", "XdCa", "AaYa",
"AaAa", "AaAd", "AaCa", "AdAd", "AdXa", "AdYa", "XaYa",
"YaCa", "XaXa", "XaCa", "AdCa", "XaAa", "XaAd", "CaXa",
"CaYa", "CaXd", "AaWa")
#taking the sum of the cges that go into each category (add, dom, epi)
mcomp[1] <- sum(cge.est[cge %in% additive])
mcomp[2] <- sum(cge.est[cge %in% dominance])
mcomp[3] <- sum(cge.est[cge %in% epistatic])
#scale and sum the components to one
names(mcomp) <- c("add","dom", "epi")
mcomp <- mcomp/sum(mcomp)
return(mcomp)
}
# loop that completes procLCA function on result file
final.results <- as.data.frame(matrix(NA, 1,4))
colnames(final.results) <- c("add","dom","epi","file")
# add counter for which row to put results in
counter<-1
for(i in seq(from=1, by=3, length.out=(nrow(dat)/3))){
curdat <- dat[i:(i+2),]
final.results[counter, 1:3] <- procLCA(curdat) #add, dom, epi component for each dataset
final.results[counter, 4] <- dat$file[i] #file name
counter <- counter + 1
}
View(final.results)
write.csv(final.results, "../results/final.resultsNOF1.csv")
View(final.results)
# leaf area excluding F1
dat <- read.csv("../data/area.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# leaf perimeter excluding F1
dat <- read.csv("../data/perimeter.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# leaf perimeter excluding F1
dat <- read.csv("../data/perimeter.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# RPA excluding F1
dat <- read.csv("../data/RPA.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# symmetry excluding F1
dat <- read.csv("../data/AR.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# length excluding F1
dat <- read.csv("../data/length.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# width excluding F1
dat <- read.csv("../data/width.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# roundness excluding F1
dat <- read.csv("../data/RWL.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# seed weight excluding F1
dat <- read.csv("../data/seed mass.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
# width excluding F1
dat <- read.csv("../data/width.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), main = "Width")
# symmetry excluding F1
dat <- read.csv("../data/AR.csv")
cmat <- as.matrix(read.csv("../data/cmat/cmatNOF1.csv"))
res <- LCA(dat,
SCS="NSC",
parental = "calc",
env=FALSE,
max.pars = 7,
ret.all=F,
Cmatrix = cmat)
plot(res, col.ramp = viridis(100), min.vi = 0.25, main = "Areal Ratio")
res$estimates
res$varimp
res$best.models
plot.genarch
